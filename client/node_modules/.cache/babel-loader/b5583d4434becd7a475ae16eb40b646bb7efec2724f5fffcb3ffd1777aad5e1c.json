{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\maxhi\\\\Desktop\\\\Projects\\\\Whitespace\\\\client\\\\src\\\\TextEditor.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useCallback, useState, useRef, use } from 'react';\nimport Quill from \"quill\";\nimport \"quill/dist/quill.snow.css\";\nimport { io } from \"socket.io-client\";\nimport { useParams } from \"react-router-dom\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst TOOLBAR_OPTIONS = [[{\n  header: [1, 2, 3, 4, 5, 6, false]\n}], [{\n  font: []\n}], [{\n  list: \"ordered\"\n}, {\n  list: \"bullet\"\n}], [\"bold\", \"italic\", \"underline\"], [{\n  color: []\n}, {\n  background: []\n}], [{\n  script: \"sub\"\n}, {\n  script: \"super\"\n}], [{\n  align: []\n}], [\"image\", \"blockquote\", \"code-block\"], [\"clean\"]];\nconst SAVE_INTERVAL_MS = 500;\nconst PREDICTION_DEBOUNCE_MS = 500;\nconst MIN_CHARS_FOR_PREDICTION = 5;\nexport default function TextEditor() {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [quill, setQuill] = useState(null);\n  const {\n    id: documentId\n  } = useParams();\n  const [isPredicting, setIsPredicting] = useState(false);\n  const debounceTimerRef = useRef(null);\n  const suggestionRef = useRef(null);\n  useEffect(() => {\n    const s = io(\"http://localhost:3001\");\n    setSocket(s);\n    return () => {\n      s.disconnect();\n    };\n  }, []);\n  useEffect(() => {\n    if (socket == null || quill == null) return;\n    const interval = setInterval(() => {\n      socket.emit(\"save-document\", quill.getContents());\n    }, SAVE_INTERVAL_MS);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [socket, quill]);\n  useEffect(() => {\n    if (socket == null || quill == null) return;\n    socket.once(\"load-document\", document => {\n      quill.setContents(document);\n      quill.enable();\n    });\n    socket.emit(\"get-document\", documentId);\n  }, [quill, socket, documentId]);\n  useEffect(() => {\n    if (socket == null || quill == null) return;\n    const handler = delta => {\n      quill.updateContents(delta);\n    };\n    socket.on(\"receive-changes\", handler);\n    return () => {\n      socket.off(\"receive-changes\", handler);\n    };\n  }, [socket, quill]);\n  const fetchPrediction = async text => {\n    try {\n      setIsPredicting(true);\n      const response = await fetch(\"http://localhost:3001/api/predict\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          text\n        })\n      });\n      if (!response.ok) {\n        throw new Error(\"Network response was not ok\");\n      }\n      const data = await response.json();\n      return data.prediction;\n    } catch (error) {\n      console.error(\"Error fetching prediction:\", error);\n      return \"\";\n    } finally {\n      setIsPredicting(false);\n    }\n  };\n  const handleTextChange = useCallback(async (delta, oldDelta, source) => {\n    if (source !== \"user\" || !quill || isPredicting) return;\n    const selection = quill.getSelection();\n    if (!selection) return;\n    if (suggestionRef.current && delta.ops) {\n      const insertOp = delta.ops.find(op => op.insert);\n      const retainOp = delta.ops.find(op => op.retain);\n      if (insertOp && retainOp && retainOp.retain === suggestionRef.current.start) {\n        quill.formatText(retainOp.retain, insertOp.insert.length, {\n          color: 'black',\n          'user-suggestion': false\n        });\n        suggestionRef.current.start += insertOp.insert.length;\n      } else if (insertOp && retainOp && retainOp.retain > suggestionRef.current.start && retainOp.retain < suggestionRef.current.start + suggestionRef.current.length) {\n        // Calculate where in the suggestion they're typing\n        const offset = retainOp.retain - suggestionRef.current.start;\n        quill.formatText(retainOp.retain, insertOp.insert.length, {\n          color: 'black',\n          'user-suggestion': false\n        });\n        const newLength = suggestionRef.current.length - offset;\n        suggestionRef.current = {\n          start: retainOp.retain + insertOp.insert.length,\n          length: newLength - insertOp.insert.length\n        };\n        if (suggestionRef.current.length <= 0) {\n          suggestionRef.current = null;\n        }\n      }\n    }\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current);\n    }\n    const cursorPosition = selection.index;\n    const fullText = quill.getText(0, cursorPosition);\n    const contextLength = Math.min(100, cursorPosition);\n    const start = Math.max(0, cursorPosition - contextLength);\n    const recentText = quill.getText(start, cursorPosition - start);\n    if (fullText.length < MIN_CHARS_FOR_PREDICTION) return;\n    if (suggestionRef.current) {\n      quill.deleteText(suggestionRef.current.start, suggestionRef.current.length);\n      suggestionRef.current = null;\n    }\n    debounceTimerRef.current = setTimeout(async () => {\n      const prediction = await fetchPrediction(recentText);\n      if (prediction && prediction.length > 0 && quill.hasFocus()) {\n        const currentSelection = quill.getSelection();\n        if (!currentSelection) return;\n        const currentPosition = currentSelection.index;\n        quill.insertText(currentPosition, prediction, {\n          color: '#aaaaaa',\n          'user-suggestion': true,\n          'non-editable': true\n        });\n        suggestionRef.current = {\n          start: currentPosition,\n          length: prediction.length\n        };\n        quill.setSelection(currentSelection.index, 0);\n      }\n    }, PREDICTION_DEBOUNCE_MS);\n  }, [quill, isPredicting]);\n  const handleKeyDown = useCallback(event => {\n    console.log(\"Key pressed:\", event.key, \"Suggestion:\", suggestionRef.current);\n    if (!quill || !suggestionRef.current) return;\n    if (event.key === 'Tab' && suggestionRef.current) {\n      event.preventDefault();\n      const {\n        start,\n        length\n      } = suggestionRef.current;\n      quill.formatText(start, length, {\n        color: 'black',\n        'user-suggestion': false\n      });\n      quill.setSelection(start + length, 0);\n      suggestionRef.current = null;\n    } else if (event.key === 'Escape' && suggestionRef.current) {\n      event.preventDefault();\n      const {\n        start,\n        length\n      } = suggestionRef.current;\n      quill.deleteText(start, length);\n      suggestionRef.current = null;\n    } else if (event.ctrlKey && event.key === 'ArrowRight' && suggestionRef.current) {\n      event.preventDefault();\n      const {\n        start,\n        length\n      } = suggestionRef.current;\n      const text = quill.getText(start, length);\n      const nextSpaceIndex = text.indexOf(' ');\n      let wordLength;\n      if (nextSpaceIndex === -1) {\n        wordLength = length;\n      } else {\n        wordLength = nextSpaceIndex + 1;\n      }\n      quill.formatText(start, wordLength, {\n        color: 'black',\n        'user-suggestion': false\n      });\n      if (wordLength < length) {\n        suggestionRef.current = {\n          start: start + wordLength,\n          length: length - wordLength\n        };\n      } else {\n        suggestionRef.current = null;\n      }\n      quill.setSelection(start + wordLength, 0);\n    }\n  }, [quill]);\n  const handleClick = useCallback(event => {\n    if (!quill || !suggestionRef.current) return;\n    const selection = quill.getSelection();\n    if (!selection) return;\n    const {\n      start,\n      length\n    } = suggestionRef.current;\n    if (selection.index >= start && selection.index <= start + length) {\n      quill.setSelection(start, 0);\n      event.preventDefault();\n    }\n  });\n  useEffect(() => {\n    if (socket == null || quill == null) return;\n    const handler = (delta, oldDelta, source) => {\n      if (source !== \"user\") return;\n      socket.emit(\"send-changes\", delta);\n    };\n    quill.on(\"text-change\", handler);\n    quill.on(\"text-change\", handleTextChange);\n    if (quill.root) {\n      quill.root.addEventListener(\"keydown\", handleKeyDown);\n      quill.root.addEventListener(\"click\", handleClick);\n    }\n    return () => {\n      quill.off(\"text-change\", handler);\n      quill.off(\"text-change\", handleTextChange);\n      if (quill.root) {\n        quill.root.removeEventListener(\"keydown\", handleKeyDown);\n        quill.root.removeEventListener(\"click\", handleClick);\n      }\n    };\n  }, [socket, quill, handleTextChange, handleKeyDown, handleClick]);\n  useEffect(() => {\n    if (!quill || !quill.root) return;\n\n    // Create a handler that runs before Quill's internal handlers\n    const preemptiveTabHandler = e => {\n      if (e.key === 'Tab' && suggestionRef.current) {\n        console.log(\"Intercepted Tab with active suggestion\");\n        // Stop the event completely\n        e.preventDefault();\n        e.stopImmediatePropagation();\n\n        // Apply the suggestion\n        const {\n          start,\n          length\n        } = suggestionRef.current;\n\n        // Use a timeout to ensure this runs after the event cycle\n        setTimeout(() => {\n          quill.formatText(start, length, {\n            color: 'black',\n            'user-suggestion': false\n          });\n          quill.setSelection(start + length, 0);\n          suggestionRef.current = null;\n        }, 0);\n        return false;\n      }\n    };\n    quill.root.addEventListener('keydown', preemptiveTabHandler, {\n      capture: true,\n      passive: false\n    });\n    return () => {\n      quill.root.removeEventListener('keydown', preemptiveTabHandler, {\n        capture: true,\n        passive: false\n      });\n    };\n  }, [quill]);\n  const wrapperRef = useCallback(wrapper => {\n    if (wrapper === null) return;\n    wrapper.innerHTML = \"\";\n    const editor = document.createElement(\"div\");\n    wrapper.append(editor);\n    const q = new Quill(editor, {\n      theme: \"snow\",\n      modules: {\n        toolbar: TOOLBAR_OPTIONS\n      }\n    });\n    q.disable();\n    q.setText(\"\");\n    setQuill(q);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"editor-container\",\n      ref: wrapperRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 322,\n      columnNumber: 13\n    }, this), isPredicting && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"prediction-indicator\",\n      children: /*#__PURE__*/_jsxDEV(\"small\", {\n        children: \"Thinking...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 325,\n        columnNumber: 21\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 324,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"editor-hint\",\n      children: /*#__PURE__*/_jsxDEV(\"small\", {\n        children: \"Press Tab to accept suggestions or Esc to reject\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 329,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 328,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 321,\n    columnNumber: 9\n  }, this);\n}\n_s(TextEditor, \"zE/6iETQkiDEGSJtYI9X2gxxUNw=\", false, function () {\n  return [useParams];\n});\n_c = TextEditor;\nvar _c;\n$RefreshReg$(_c, \"TextEditor\");","map":{"version":3,"names":["React","useEffect","useCallback","useState","useRef","use","Quill","io","useParams","jsxDEV","_jsxDEV","TOOLBAR_OPTIONS","header","font","list","color","background","script","align","SAVE_INTERVAL_MS","PREDICTION_DEBOUNCE_MS","MIN_CHARS_FOR_PREDICTION","TextEditor","_s","socket","setSocket","quill","setQuill","id","documentId","isPredicting","setIsPredicting","debounceTimerRef","suggestionRef","s","disconnect","interval","setInterval","emit","getContents","clearInterval","once","document","setContents","enable","handler","delta","updateContents","on","off","fetchPrediction","text","response","fetch","method","headers","body","JSON","stringify","ok","Error","data","json","prediction","error","console","handleTextChange","oldDelta","source","selection","getSelection","current","ops","insertOp","find","op","insert","retainOp","retain","start","formatText","length","offset","newLength","clearTimeout","cursorPosition","index","fullText","getText","contextLength","Math","min","max","recentText","deleteText","setTimeout","hasFocus","currentSelection","currentPosition","insertText","setSelection","handleKeyDown","event","log","key","preventDefault","ctrlKey","nextSpaceIndex","indexOf","wordLength","handleClick","root","addEventListener","removeEventListener","preemptiveTabHandler","e","stopImmediatePropagation","capture","passive","wrapperRef","wrapper","innerHTML","editor","createElement","append","q","theme","modules","toolbar","disable","setText","className","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/maxhi/Desktop/Projects/Whitespace/client/src/TextEditor.js"],"sourcesContent":["import React, { useEffect, useCallback, useState, useRef, use } from 'react'\r\nimport Quill from \"quill\"\r\nimport \"quill/dist/quill.snow.css\"\r\nimport { io } from \"socket.io-client\"\r\nimport { useParams } from \"react-router-dom\"\r\n\r\nconst TOOLBAR_OPTIONS = [\r\n    [{ header: [1, 2, 3, 4, 5, 6, false] }],\r\n    [{ font: [] }],\r\n    [{ list: \"ordered\" }, { list: \"bullet\" }],\r\n    [\"bold\", \"italic\", \"underline\"],\r\n    [{ color: [] }, { background: [] }],\r\n    [{ script: \"sub\" }, { script: \"super\" }],\r\n    [{ align: [] }],\r\n    [\"image\", \"blockquote\", \"code-block\"],\r\n    [\"clean\"],\r\n]\r\nconst SAVE_INTERVAL_MS = 500\r\nconst PREDICTION_DEBOUNCE_MS = 500\r\nconst MIN_CHARS_FOR_PREDICTION = 5\r\n\r\nexport default function TextEditor() {\r\n    const [socket, setSocket] = useState(null)\r\n    const [quill, setQuill] = useState(null)\r\n    const { id: documentId } = useParams()\r\n    const [isPredicting, setIsPredicting] = useState(false)\r\n    const debounceTimerRef = useRef(null)\r\n    const suggestionRef = useRef(null)\r\n\r\n    useEffect(() => {\r\n        const s = io(\"http://localhost:3001\")\r\n        setSocket(s)\r\n\r\n        return () => {\r\n            s.disconnect()\r\n        }\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n        if (socket == null || quill == null) return\r\n\r\n        const interval = setInterval(() => {\r\n            socket.emit(\"save-document\", quill.getContents())\r\n        }, SAVE_INTERVAL_MS)\r\n\r\n        return () => {\r\n            clearInterval(interval)\r\n        }\r\n    }, [socket, quill])\r\n\r\n    useEffect(() => {\r\n        if (socket == null || quill == null) return\r\n\r\n        socket.once(\"load-document\", (document) => {\r\n            quill.setContents(document)\r\n            quill.enable()\r\n        })\r\n\r\n        socket.emit(\"get-document\", documentId)\r\n    }, [quill, socket, documentId])\r\n\r\n    useEffect(() => {\r\n        if (socket == null || quill == null) return\r\n        \r\n        const handler = (delta) => {\r\n            quill.updateContents(delta)\r\n        }\r\n        socket.on(\"receive-changes\", handler)\r\n\r\n        return () => {\r\n            socket.off(\"receive-changes\", handler)\r\n        }\r\n    }, [socket, quill])\r\n\r\n    const fetchPrediction = async (text) => {\r\n        try {\r\n            setIsPredicting(true)\r\n            const response = await fetch(\"http://localhost:3001/api/predict\", {\r\n                method: \"POST\",\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ text }),\r\n            });\r\n            if (!response.ok) {\r\n                throw new Error(\"Network response was not ok\")\r\n            }\r\n            const data = await response.json()\r\n            return data.prediction\r\n        } catch (error) {\r\n            console.error(\"Error fetching prediction:\", error)\r\n            return \"\"\r\n        } finally {\r\n            setIsPredicting(false)\r\n        }\r\n    };\r\n\r\n    const handleTextChange = useCallback(async (delta, oldDelta, source) => {\r\n        if (source !== \"user\" || !quill || isPredicting) return\r\n\r\n        const selection = quill.getSelection();\r\n        if (!selection) return\r\n\r\n        if (suggestionRef.current && delta.ops) {\r\n            const insertOp = delta.ops.find(op => op.insert)\r\n            const retainOp = delta.ops.find(op => op.retain)\r\n\r\n            if (insertOp && retainOp && retainOp.retain === suggestionRef.current.start) {\r\n                quill.formatText(retainOp.retain, insertOp.insert.length, { \r\n                    color: 'black', \r\n                    'user-suggestion': false \r\n                });\r\n                \r\n                suggestionRef.current.start += insertOp.insert.length;\r\n            }\r\n            else if (insertOp && retainOp && \r\n                     retainOp.retain > suggestionRef.current.start && \r\n                     retainOp.retain < suggestionRef.current.start + suggestionRef.current.length) {\r\n                \r\n                // Calculate where in the suggestion they're typing\r\n                const offset = retainOp.retain - suggestionRef.current.start;\r\n                \r\n                quill.formatText(retainOp.retain, insertOp.insert.length, { \r\n                    color: 'black', \r\n                    'user-suggestion': false \r\n                });\r\n                \r\n                const newLength = suggestionRef.current.length - offset;\r\n                suggestionRef.current = {\r\n                    start: retainOp.retain + insertOp.insert.length,\r\n                    length: newLength - insertOp.insert.length\r\n                };\r\n                \r\n                if (suggestionRef.current.length <= 0) {\r\n                    suggestionRef.current = null;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (debounceTimerRef.current) {\r\n            clearTimeout(debounceTimerRef.current)\r\n        }\r\n\r\n        const cursorPosition = selection.index\r\n        const fullText = quill.getText(0, cursorPosition)\r\n        const contextLength = Math.min(100, cursorPosition)\r\n        const start = Math.max(0, cursorPosition - contextLength)\r\n        const recentText = quill.getText(start, cursorPosition - start)\r\n\r\n        if (fullText.length < MIN_CHARS_FOR_PREDICTION) return\r\n\r\n        if (suggestionRef.current) {\r\n            quill.deleteText(\r\n                suggestionRef.current.start,\r\n                suggestionRef.current.length,\r\n            )\r\n            suggestionRef.current = null\r\n        }\r\n\r\n        debounceTimerRef.current = setTimeout(async () => {\r\n            const prediction = await fetchPrediction(recentText)\r\n            if (prediction && prediction.length > 0 && quill.hasFocus()) {\r\n                const currentSelection = quill.getSelection();\r\n                if (!currentSelection) return;\r\n                \r\n                const currentPosition = currentSelection.index;\r\n                \r\n                quill.insertText(\r\n                    currentPosition, \r\n                    prediction,\r\n                    { color: '#aaaaaa', 'user-suggestion': true, 'non-editable': true },\r\n                );\r\n                \r\n                suggestionRef.current = {\r\n                    start: currentPosition,\r\n                    length: prediction.length\r\n                };\r\n\r\n                quill.setSelection(currentSelection.index, 0);\r\n            }\r\n        }, PREDICTION_DEBOUNCE_MS);\r\n    }, [quill, isPredicting])\r\n\r\n    const handleKeyDown = useCallback((event) => {\r\n        console.log(\"Key pressed:\", event.key, \"Suggestion:\", suggestionRef.current)\r\n        if (!quill || !suggestionRef.current) return\r\n\r\n        if (event.key === 'Tab' && suggestionRef.current) {\r\n            event.preventDefault();\r\n            const { start, length } = suggestionRef.current;\r\n            quill.formatText(start, length, { color: 'black', 'user-suggestion': false });\r\n            quill.setSelection(start + length, 0);\r\n            suggestionRef.current = null;\r\n        } else if (event.key === 'Escape' && suggestionRef.current) {\r\n            event.preventDefault();\r\n            \r\n            const { start, length } = suggestionRef.current;\r\n            quill.deleteText(start, length);\r\n            suggestionRef.current = null;\r\n        } else if (event.ctrlKey && event.key === 'ArrowRight' && suggestionRef.current) {\r\n            event.preventDefault();\r\n            const { start, length } = suggestionRef.current;\r\n            \r\n            const text = quill.getText(start, length);\r\n            const nextSpaceIndex = text.indexOf(' ');\r\n            \r\n            let wordLength;\r\n            if (nextSpaceIndex === -1) {\r\n                wordLength = length;\r\n            } else {\r\n                wordLength = nextSpaceIndex + 1;\r\n            }\r\n            \r\n            quill.formatText(start, wordLength, { color: 'black', 'user-suggestion': false });\r\n            \r\n            if (wordLength < length) {\r\n                suggestionRef.current = {\r\n                    start: start + wordLength,\r\n                    length: length - wordLength\r\n                };\r\n            } else {\r\n                suggestionRef.current = null;\r\n            }\r\n            quill.setSelection(start + wordLength, 0);\r\n        }\r\n    }, [quill]);\r\n\r\n    const handleClick = useCallback((event) => {\r\n        if (!quill || !suggestionRef.current) return;\r\n    \r\n        const selection = quill.getSelection();\r\n        if (!selection) return;\r\n    \r\n        const { start, length } = suggestionRef.current;\r\n    \r\n        if (selection.index >= start && selection.index <= start + length) {\r\n            quill.setSelection(start, 0);\r\n            event.preventDefault();\r\n        }\r\n    });\r\n\r\n    useEffect(() => {\r\n        if (socket == null || quill == null) return\r\n\r\n        const handler = (delta, oldDelta, source) => {\r\n            if (source !== \"user\") return\r\n            socket.emit(\"send-changes\", delta)\r\n        }\r\n        quill.on(\"text-change\", handler)\r\n        quill.on(\"text-change\", handleTextChange)\r\n\r\n        if (quill.root) {\r\n            quill.root.addEventListener(\"keydown\", handleKeyDown)\r\n            quill.root.addEventListener(\"click\", handleClick)\r\n        }\r\n\r\n        return () => {\r\n            quill.off(\"text-change\", handler)\r\n            quill.off(\"text-change\", handleTextChange)\r\n            if (quill.root) {\r\n                quill.root.removeEventListener(\"keydown\", handleKeyDown)\r\n                quill.root.removeEventListener(\"click\", handleClick)\r\n            }\r\n        }\r\n    }, [socket, quill, handleTextChange, handleKeyDown, handleClick])\r\n\r\n\r\n    useEffect(() => {\r\n        if (!quill || !quill.root) return;\r\n        \r\n        // Create a handler that runs before Quill's internal handlers\r\n        const preemptiveTabHandler = (e) => {\r\n          if (e.key === 'Tab' && suggestionRef.current) {\r\n            console.log(\"Intercepted Tab with active suggestion\");\r\n            // Stop the event completely\r\n            e.preventDefault();\r\n            e.stopImmediatePropagation();\r\n            \r\n            // Apply the suggestion\r\n            const { start, length } = suggestionRef.current;\r\n            \r\n            // Use a timeout to ensure this runs after the event cycle\r\n            setTimeout(() => {\r\n              quill.formatText(start, length, { color: 'black', 'user-suggestion': false });\r\n              quill.setSelection(start + length, 0);\r\n              suggestionRef.current = null;\r\n            }, 0);\r\n            \r\n            return false;\r\n          }\r\n        };\r\n        \r\n        quill.root.addEventListener('keydown', preemptiveTabHandler, {\r\n          capture: true,\r\n          passive: false\r\n        });\r\n        \r\n        return () => {\r\n          quill.root.removeEventListener('keydown', preemptiveTabHandler, {\r\n            capture: true,\r\n            passive: false\r\n          });\r\n        };\r\n      }, [quill]);\r\n        \r\n    const wrapperRef = useCallback((wrapper) => {\r\n        if (wrapper === null) return\r\n\r\n        wrapper.innerHTML = \"\"\r\n        const editor = document.createElement(\"div\")\r\n        wrapper.append(editor)\r\n        const q = new Quill(editor, {\r\n            theme: \"snow\",\r\n            modules: { toolbar: TOOLBAR_OPTIONS } })\r\n\r\n        q.disable()\r\n        q.setText(\"\")\r\n\r\n        setQuill(q)\r\n\r\n    }, [])\r\n  return (\r\n        <div className=\"container\">\r\n            <div className=\"editor-container\" ref={wrapperRef}></div>\r\n            {isPredicting && (\r\n                <div className=\"prediction-indicator\">\r\n                    <small>Thinking...</small>\r\n                </div>\r\n            )}\r\n            <div className=\"editor-hint\">\r\n                <small>Press Tab to accept suggestions or Esc to reject</small>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}